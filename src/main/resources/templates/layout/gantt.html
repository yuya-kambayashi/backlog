<!DOCTYPE html>
<html
        xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
        layout:decorate="~{layout/layout}"
        lang="ja">

<head>
    <title>ガントチャート｜Backlog</title>

</head>

<body>
<div layout:fragment="content">
    <div class="card-body table-responsive">
        <table class="table table-bordered">
            <thead>
            <tr>
                <th>名称</th>
                <th>開始予定日</th>
                <th>開始終了日</th>
                <th>実績開始日</th>
                <th>実績終了日</th>
            </tr>
            </thead>
            <tbody>
            <tr th:each="issue : ${issues}" th:object="${issue}">
                <td>
                    <a th:href="@{/projects/{projectKey}/view/{issueNumber}(projectKey=${project.projectKey}, issueNumber=*{id.getIssueNumber()})}"
                       th:text="${issue.getIssueKey()}"></a>
                </td>
                <td th:text="${issue.plannedStartDate}"></td>
                <td th:text="${issue.limitDate}"></td>
                <td th:text="${issue.acutualStartDate}"></td>
                <td th:text="${issue.acutualEndDate}"></td>
            </tr>
            </tbody>
        </table>
    </div>
    <div class="chartCard">
        <div class="chartBox">
            <canvas id="myChart"></canvas>
            <input type="month" onchange="chartFilter(this)"/>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script th:inline="javascript">
        const colors = ['rgba(255, 26, 104, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)']
        console.log(colors);
        const maps = [[${maps}]];
        console.log(maps);

        const inputData = JSON.parse(maps.toString());
        console.log(inputData);


        // setup
        const data = {
            datasets: [
                {
                    // 計画
                    data: [
                        // {x: ['2025-05-02', '2025-05-06'], y: 'Task 1', name: 'James', status: 2},
                        // {x: ['2025-05-06', '2025-05-12'], y: 'Task 2', name: 'Luna', status: 2},
                        {x: ['2025-05-08', '2025-05-12'], y: 'Task 3', name: 'David', status: 2},
                    ],
                    backgroundColor: (ctx) => {
                        return colors[ctx.raw.status];
                    },
                    borderSkipped: false,
                    borderRadius: 10,
                    barPercentage: 0.5

                },
                {
                    // 実績
                    data: [
                        // {x: ['2025-05-02', '2025-05-06'], y: 'Task 1', name: 'James', status: 2},
                        // {x: ['2025-05-06', '2025-05-12'], y: 'Task 2', name: 'Luna', status: 2},
                        {x: ['2025-05-08', '2025-05-12'], y: 'Task 3', name: 'David', status: 2},
                    ],
                    backgroundColor: 'rgba(255, 26, 104, 1)',
                    borderSkipped: false,
                    borderRadius: 10,
                    barPercentage: 0.5

                }]
        };

        const labelsArray = data.datasets[0].data.map((dataPoint, index) => {
            return dataPoint.y;
        });
        const labelsArrayFilter = [...new Set(labelsArray)];

        const todayLine = {
            id: 'todayLine',
            afterDatasetsDraw(chart, args, pluginOptions) {
                const {
                    ctx, data, chartArea: {top, bottom, left, right},
                    scales: {x, y}
                } = chart;

                ctx.save();

                ctx.beginPath();
                ctx.lineWidth = 3;
                ctx.strokeStyle = 'rgba(102, 102, 102, 1)';
                ctx.setLineDash([6, 6]);
                ctx.moveTo(x.getPixelForValue(new Date()), top);
                ctx.lineTo(x.getPixelForValue(new Date()), bottom);
                ctx.stroke();
                ctx.restore();

                ctx.setLineDash([]);

                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(102, 102, 102, 1)';
                ctx.fillStyle = 'rgba(102, 102, 102, 1)';
                ctx.moveTo(x.getPixelForValue(new Date()), top + 3);
                ctx.lineTo(x.getPixelForValue(new Date()) - 6, top - 6);
                ctx.lineTo(x.getPixelForValue(new Date()) + 6, top - 6);
                ctx.closePath();
                ctx.stroke();
                ctx.fill();
                ctx.restore();

                ctx.font = 'bold 12px sans-serif';
                ctx.fillStyle = 'rgba(102, 102, 102, 1)';
                ctx.textAlign = 'center';
                ctx.fillText('Today', x.getPixelForValue(new Date()), bottom + 15);
                ctx.restore();


            }
        }

        const assignedTasks = {
            id: 'assignedTasks',
            afterDatasetsDraw(chart, args, pluginOptions) {
                const {
                    ctx, data, chartArea: {top, bottom, left, right},
                    scales: {x, y}
                } = chart;

                ctx.save();
                ctx.font = 'border 12px sans-serif';
                ctx.fillStyle = 'black';
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'left';
                data.datasets[0].data.forEach((datapoint, index) => {
                    if (y.getPixelForValue(index) > top && y.getPixelForValue(index) < bottom) {
                        ctx.fillText(datapoint.name, 10, y.getPixelForValue(index));
                    }
                });
                ctx.fillText('Names', 10, top - 15);
                ctx.restore();

            }
        }

        // weekend
        const weekend = {
            id: 'weekend',
            afterDatasetsDraw(chart, args, pluginOptions) {
                const {
                    ctx, chartArea: {top, bottom, left, right, width, height},
                    scales: {x, y}
                } = chart;

                ctx.save();

                x.ticks.forEach((tick, index) => {
                    const day = new Date(tick.value).getDay();
                    if (day === 0 || day === 6) {
                        ctx.fillStyle = pluginOptions.weekendColor;
                        ctx.fillRect(x.getPixelForValue(tick.value), top, x.getPixelForValue(new Date(tick.value).setHours(24)) - x.getPixelForValue(tick.value), height);
                    }
                })


            }
        }

        // config
        const config = {
            type: 'bar',
            data,
            options: {
                layout: {
                    padding: {
                        left: 100,
                        bottom: 20
                    }
                },

                indexAxis: 'y',
                scales: {
                    x: {
                        position: 'top',
                        type: 'time',
                        time: {
                            unit: 'day',
                            displayFormats: {
                                day: 'd'
                            }
                        },
                        min: '2025-05-01',
                        max: '2025-05-31'
                    },
                    y: {
                        min: 0,
                        max: 8,
                        labels: labelsArrayFilter,
                    }
                },
                plugins: {
                    weekend: {
                        weekendColor: 'rgba(102, 102, 102, 0.2)'
                    },
                    legend: {
                        display: false
                    },
                    tooltip: {
                        displayColors: false,
                        yAlign: 'bottom',
                        callbacks: {
                            label: (ctx) => {
                                return '';
                            },
                            title: (ctx) => {
                                console.log(ctx[0].raw.x)
                                const startDate = new Date(ctx[0].raw.x[0]);
                                const endDate = new Date(ctx[0].raw.x[1]);
                                const formattedStartDate = startDate.toLocaleString([], {
                                    year: 'numeric',
                                    month: 'short',
                                    day: 'numeric',
                                });
                                const formattedEndDate = endDate.toLocaleString([], {
                                    year: 'numeric',
                                    month: 'short',
                                    day: 'numeric',
                                });
                                return [ctx[0].raw.name, `Task Deadline: ${formattedStartDate} - ${formattedEndDate}`];
                            }
                        }
                    }
                }
            },
            plugins: [todayLine, assignedTasks, weekend]
        };

        // render init block
        const myChart = new Chart(
            document.getElementById('myChart'),
            config
        );

        // 初期化処理
        importIssueData();



        console.log(myChart)

        myChart.update();


        function chartFilter(date) {
            const year = date.value.substring(0, 4);
            const month = date.value.substring(5, 7);
            const lastDay = (y, m) => {
                return new Date(y, m, 0).getDate();
            }

            const startDate = `${year}-${month}-01`;
            const endDate = `${year}-${month}-${lastDay(year, month)}`;

            myChart.config.options.scales.x.min = startDate;
            myChart.config.options.scales.x.max = endDate;
            myChart.update()

        }

        function importIssueData() {
            console.log("addTask");

            // いったんダミーを削除
            // myChart.data.datasets[0].data.length = 0;

            // 連携データを追加
            inputData.forEach((input) =>{

                const startDate = input.x[0];
                const endDate = input.x[1];
                const taskName = input.y;
                const assigner = input.name;
                const status = input.status;

                const arraylength = myChart.data.datasets[0].data.length;

                myChart.data.datasets[0].data[arraylength] = ({
                        x: [startDate, endDate],
                        y: taskName,
                        name: assigner,
                        status: parseInt(status)
                    }
                );
            })
            myChart.update();
            console.log(data);

            // const labelsArray = data.datasets[0].data.map((dataPoint, index) => {
            //     return dataPoint.y;
            // });
            // config.options.scales.y.labels = [...new Set(labelsArray)]
            //
            // console.log(data);
            // console.log(config.options.scales.y.labels)
        }
    </script>
</div>
</body>
</html>
